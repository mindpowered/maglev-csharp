// Generated by Haxe 4.1.1

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace haxe.crypto {
	public class BaseCode : global::haxe.lang.HxObject {
		
		public BaseCode(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public BaseCode(global::haxe.io.Bytes @base) {
			#line 33 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
			global::haxe.crypto.BaseCode.__hx_ctor_haxe_crypto_BaseCode(this, @base);
		}
		#line default
		
		protected static void __hx_ctor_haxe_crypto_BaseCode(global::haxe.crypto.BaseCode __hx_this, global::haxe.io.Bytes @base) {
			unchecked {
				#line 34 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
				int len = @base.length;
				int nbits = 1;
				#line 36 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
				while (( len > ( 1 << nbits ) )) {
					#line 37 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
					 ++ nbits;
				}
				
				#line 38 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
				if (( ( nbits > 8 ) || ( len != ( 1 << nbits ) ) )) {
					#line 39 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
					throw ((global::System.Exception) (global::haxe.Exception.thrown("BaseCode : base length must be a power of two.")) );
				}
				
				#line 40 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
				__hx_this.@base = @base;
				__hx_this.nbits = nbits;
			}
			#line default
		}
		
		
		public static string encode(string s, string @base) {
			#line 129 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
			global::haxe.crypto.BaseCode b = new global::haxe.crypto.BaseCode(((global::haxe.io.Bytes) (global::haxe.io.Bytes.ofString(@base, null)) ));
			return b.encodeString(s);
		}
		#line default
		
		public static string decode(string s, string @base) {
			#line 134 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
			global::haxe.crypto.BaseCode b = new global::haxe.crypto.BaseCode(((global::haxe.io.Bytes) (global::haxe.io.Bytes.ofString(@base, null)) ));
			return b.decodeString(s);
		}
		#line default
		
		public global::haxe.io.Bytes @base;
		
		public int nbits;
		
		public global::Array<int> tbl;
		
		public virtual global::haxe.io.Bytes encodeBytes(global::haxe.io.Bytes b) {
			unchecked {
				#line 48 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
				int nbits = this.nbits;
				global::haxe.io.Bytes @base = this.@base;
				#line 50 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
				int size = ( ( b.length * 8 ) / nbits );
				global::haxe.io.Bytes @out = global::haxe.io.Bytes.alloc(( size + (( (( ( ( b.length * 8 ) % nbits ) == 0 )) ? (0) : (1) )) ));
				#line 52 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
				int buf = 0;
				int curbits = 0;
				#line 54 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
				int mask = ( (( 1 << nbits )) - 1 );
				int pin = 0;
				#line 56 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
				int pout = 0;
				while (( pout < size )) {
					#line 58 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
					while (( curbits < nbits )) {
						#line 59 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						curbits += 8;
						buf <<= 8;
						#line 61 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						buf |= ((int) (b.b[pin++]) );
					}
					
					#line 63 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
					curbits -= nbits;
					@out.b[pout++] = ((byte) (((int) (@base.b[( ( buf >> curbits ) & mask )]) )) );
				}
				
				#line 66 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
				if (( curbits > 0 )) {
					#line 67 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
					@out.b[pout++] = ((byte) (((int) (@base.b[( ( buf << ( nbits - curbits ) ) & mask )]) )) );
				}
				
				#line 68 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
				return @out;
			}
			#line default
		}
		
		
		public virtual void initTable() {
			unchecked {
				#line 73 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
				global::Array<int> tbl = new global::Array<int>();
				{
					#line 74 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
					int _g = 0;
					#line 74 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
					while (( _g < 256 )) {
						#line 74 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						int i = _g++;
						tbl[i] = -1;
					}
					
				}
				
				#line 76 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
				{
					#line 76 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
					int _g1 = 0;
					#line 76 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
					int _g2 = this.@base.length;
					#line 76 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
					while (( _g1 < _g2 )) {
						#line 76 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						int i1 = _g1++;
						tbl[((int) (this.@base.b[i1]) )] = i1;
					}
					
				}
				
				#line 78 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
				this.tbl = tbl;
			}
			#line default
		}
		
		
		public virtual global::haxe.io.Bytes decodeBytes(global::haxe.io.Bytes b) {
			unchecked {
				#line 85 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
				int nbits = this.nbits;
				global::haxe.io.Bytes @base = this.@base;
				#line 87 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
				if (( this.tbl == null )) {
					#line 88 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
					this.initTable();
				}
				
				#line 89 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
				global::Array<int> tbl = this.tbl;
				int size = ( ( b.length * nbits ) >> 3 );
				#line 91 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
				global::haxe.io.Bytes @out = global::haxe.io.Bytes.alloc(size);
				int buf = 0;
				#line 93 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
				int curbits = 0;
				int pin = 0;
				#line 95 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
				int pout = 0;
				while (( pout < size )) {
					#line 97 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
					while (( curbits < 8 )) {
						#line 98 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						curbits += nbits;
						buf <<= nbits;
						#line 100 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						int i = tbl[((int) (b.b[pin++]) )];
						if (( i == -1 )) {
							#line 102 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
							throw ((global::System.Exception) (global::haxe.Exception.thrown("BaseCode : invalid encoded char")) );
						}
						
						#line 103 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						buf |= i;
					}
					
					#line 105 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
					curbits -= 8;
					@out.b[pout++] = ((byte) (( ( buf >> curbits ) & 255 )) );
				}
				
				#line 108 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
				return @out;
			}
			#line default
		}
		
		
		public virtual string encodeString(string s) {
			#line 116 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
			return this.encodeBytes(global::haxe.io.Bytes.ofString(s, null)).toString();
		}
		#line default
		
		public virtual string decodeString(string s) {
			#line 124 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
			return this.decodeBytes(global::haxe.io.Bytes.ofString(s, null)).toString();
		}
		#line default
		
		public override double __hx_setField_f(string field, int hash, double @value, bool handleProperties) {
			unchecked {
				#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
				switch (hash) {
					case 388680308:
					{
						#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						this.nbits = ((int) (@value) );
						#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						return @value;
					}
					
					
					default:
					{
						#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						return base.__hx_setField_f(field, hash, @value, handleProperties);
					}
					
				}
				
			}
			#line default
		}
		
		
		public override object __hx_setField(string field, int hash, object @value, bool handleProperties) {
			unchecked {
				#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
				switch (hash) {
					case 5790526:
					{
						#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						this.tbl = ((global::Array<int>) (global::Array<object>.__hx_cast<int>(((global::Array) (@value) ))) );
						#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						return @value;
					}
					
					
					case 388680308:
					{
						#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						this.nbits = ((int) (global::haxe.lang.Runtime.toInt(@value)) );
						#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						return @value;
					}
					
					
					case 1091627025:
					{
						#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						this.@base = ((global::haxe.io.Bytes) (@value) );
						#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						return @value;
					}
					
					
					default:
					{
						#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						return base.__hx_setField(field, hash, @value, handleProperties);
					}
					
				}
				
			}
			#line default
		}
		
		
		public override object __hx_getField(string field, int hash, bool throwErrors, bool isCheck, bool handleProperties) {
			unchecked {
				#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
				switch (hash) {
					case 1601245343:
					{
						#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "decodeString", 1601245343)) );
					}
					
					
					case 688014215:
					{
						#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "encodeString", 688014215)) );
					}
					
					
					case 95523933:
					{
						#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "decodeBytes", 95523933)) );
					}
					
					
					case 645255902:
					{
						#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "initTable", 645255902)) );
					}
					
					
					case 1227765365:
					{
						#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "encodeBytes", 1227765365)) );
					}
					
					
					case 5790526:
					{
						#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						return this.tbl;
					}
					
					
					case 388680308:
					{
						#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						return this.nbits;
					}
					
					
					case 1091627025:
					{
						#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						return this.@base;
					}
					
					
					default:
					{
						#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						return base.__hx_getField(field, hash, throwErrors, isCheck, handleProperties);
					}
					
				}
				
			}
			#line default
		}
		
		
		public override double __hx_getField_f(string field, int hash, bool throwErrors, bool handleProperties) {
			unchecked {
				#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
				switch (hash) {
					case 388680308:
					{
						#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						return ((double) (this.nbits) );
					}
					
					
					default:
					{
						#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						return base.__hx_getField_f(field, hash, throwErrors, handleProperties);
					}
					
				}
				
			}
			#line default
		}
		
		
		public override object __hx_invokeField(string field, int hash, object[] dynargs) {
			unchecked {
				#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
				switch (hash) {
					case 1601245343:
					{
						#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						return this.decodeString(global::haxe.lang.Runtime.toString(dynargs[0]));
					}
					
					
					case 688014215:
					{
						#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						return this.encodeString(global::haxe.lang.Runtime.toString(dynargs[0]));
					}
					
					
					case 95523933:
					{
						#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						return this.decodeBytes(((global::haxe.io.Bytes) (dynargs[0]) ));
					}
					
					
					case 645255902:
					{
						#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						this.initTable();
						#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						break;
					}
					
					
					case 1227765365:
					{
						#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						return this.encodeBytes(((global::haxe.io.Bytes) (dynargs[0]) ));
					}
					
					
					default:
					{
						#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
						return base.__hx_invokeField(field, hash, dynargs);
					}
					
				}
				
				#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
				return null;
			}
			#line default
		}
		
		
		public override void __hx_getFields(global::Array<string> baseArr) {
			#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
			baseArr.push("tbl");
			#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
			baseArr.push("nbits");
			#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
			baseArr.push("base");
			#line 28 "/opt/haxe/std/haxe/crypto/BaseCode.hx"
			base.__hx_getFields(baseArr);
		}
		#line default
		
	}
}


